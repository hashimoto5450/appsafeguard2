import { AxiosResponse } from 'axios';
import * as cheerio from 'cheerio';
import { InsertVulnerability } from '@shared/schema';

// セキュリティチェック項目の結果（安全・脆弱性あり）を表すインターフェース
interface SecurityCheckResult {
  scanId: number;
  name: string;
  description: string;
  url: string;
  severity: 'safe' | 'high' | 'medium' | 'low';
  category: string;
  details: any;
  status: string;
  passed: boolean;
}

class VulnerabilityDetector {
  async detectVulnerabilities(
    url: string, 
    response: AxiosResponse, 
    scanLevel: string
  ): Promise<InsertVulnerability[]> {
    const vulnerabilities: InsertVulnerability[] = [];
    const results: SecurityCheckResult[] = [];
    
    // 基本的なセキュリティチェック（すべてのスキャンレベルで実行）
    // Check security headers
    this.checkSecurityHeaders(url, response, results);
    
    // Check for insecure cookies
    this.checkCookies(url, response, results);
    
    // Check for XSS vulnerabilities in the page content
    this.checkXssVulnerabilities(url, response, results);
    
    // サーバー情報の漏洩チェック
    this.checkServerInformationLeakage(url, response, results);
    
    // HTTPSプロトコル検証
    this.checkHttpsUsage(url, response, results);
    
    // For standard and detailed scans, perform more checks
    if (scanLevel === 'standard' || scanLevel === 'detailed') {
      // Check for potentially vulnerable JavaScript libraries
      this.checkJavaScriptLibraries(url, response, results);
      
      // Check for CSRF vulnerabilities
      this.checkCsrfVulnerabilities(url, response, results);
      
      // Check for improper CORS policy
      this.checkCorsPolicy(url, response, results);
      
      // Check robots.txt file
      if (url.endsWith('/robots.txt') || url.endsWith('/')) {
        this.checkRobotsTxt(url, response, results);
      }
    }
    
    // For detailed scans, perform even more checks
    if (scanLevel === 'detailed') {
      // Check for potential SQL injection points
      this.checkSqlInjectionVulnerabilities(url, response, results);
      
      // Check for sensitive information leakage
      this.checkSensitiveInformationLeakage(url, response, results);
      
      // Check for password fields over non-HTTPS
      this.checkInsecurePasswordFields(url, response, results);
      
      // Check for file upload vulnerabilities
      this.checkFileUploadVulnerabilities(url, response, results);
      
      // Check for old HTTP protocol
      this.checkOldHttpProtocol(url, response, results);
      
      // Check for sensitive info in HTML comments
      this.checkCommentsForSensitiveInfo(url, response, results);
      
      // Check for old TLS/SSL versions (HTTPS URLs only)
      if (url.startsWith('https')) {
        this.checkOldTlsVersions(url, response, results);
      }
      
      // Check for public endpoints that might require authentication
      this.checkUnauthenticatedEndpoints(url, response, results);
    }
    
    // 結果をInsertVulnerabilityに変換
    // 脆弱性のあるものだけを返す（passedがfalseのもの）
    for (const result of results) {
      if (!result.passed) {
        vulnerabilities.push({
          scanId: result.scanId,
          name: result.name,
          description: result.description,
          url: result.url,
          severity: result.severity === 'safe' ? 'low' : result.severity, // 'safe'は使わないため'low'に変換
          category: result.category,
          details: result.details,
          status: result.status
        });
      } else {
        // 安全なチェック項目も脆弱性として追加
        vulnerabilities.push({
          scanId: result.scanId,
          name: result.name,
          description: result.description,
          url: result.url,
          severity: 'safe', // 安全な項目は'safe'という重要度を設定
          category: result.category,
          details: { ...result.details, passed: true },
          status: 'safe' // ステータスも'safe'に設定
        });
      }
    }
    
    return vulnerabilities;
  }
  
  // 新しいメソッド: HTTPSの使用状況を確認
  private checkHttpsUsage(url: string, response: AxiosResponse, results: SecurityCheckResult[]) {
    if (url.startsWith('https')) {
      results.push({
        scanId: 0,
        name: 'HTTPS Protocol',
        description: 'The site uses HTTPS protocol which encrypts data transmission.',
        url,
        severity: 'safe',
        category: 'Transport Security',
        details: { protocol: 'https' },
        status: 'safe',
        passed: true
      });
    } else {
      results.push({
        scanId: 0,
        name: 'Non-HTTPS Protocol',
        description: 'The site uses HTTP protocol which does not encrypt data transmission.',
        url,
        severity: 'medium',
        category: 'Transport Security',
        details: { protocol: 'http' },
        status: 'pending',
        passed: false
      });
    }
  }
  
  private checkSecurityHeaders(url: string, response: AxiosResponse, results: SecurityCheckResult[]) {
    const headers = response.headers;
    
    // Check Content-Security-Policy (CSP)
    if (headers['content-security-policy']) {
      results.push({
        scanId: 0,
        name: 'Content-Security-Policy Header',
        description: 'The Content-Security-Policy header is properly set, which helps prevent XSS attacks.',
        url,
        severity: 'safe',
        category: 'Header Configuration',
        details: { header: 'content-security-policy', value: headers['content-security-policy'] },
        status: 'safe',
        passed: true
      });
    } else {
      results.push({
        scanId: 0,
        name: 'Missing Content-Security-Policy Header',
        description: 'The Content-Security-Policy header is not set, which can lead to Cross-Site Scripting (XSS) attacks.',
        url,
        severity: 'medium',
        category: 'Header Configuration',
        details: { header: 'content-security-policy', missing: true },
        status: 'pending',
        passed: false
      });
    }
    
    // Check X-XSS-Protection
    if (headers['x-xss-protection']) {
      results.push({
        scanId: 0,
        name: 'X-XSS-Protection Header',
        description: 'The X-XSS-Protection header is properly set, which helps protect against XSS attacks in older browsers.',
        url,
        severity: 'safe',
        category: 'Header Configuration',
        details: { header: 'x-xss-protection', value: headers['x-xss-protection'] },
        status: 'safe',
        passed: true
      });
    } else {
      results.push({
        scanId: 0,
        name: 'Missing X-XSS-Protection Header',
        description: 'The X-XSS-Protection header is not set, which can lead to XSS attacks in older browsers.',
        url,
        severity: 'low',
        category: 'Header Configuration',
        details: { header: 'x-xss-protection', missing: true },
        status: 'pending',
        passed: false
      });
    }
    
    // Check Strict-Transport-Security (HSTS)
    if (url.startsWith('https')) {
      if (headers['strict-transport-security']) {
        results.push({
          scanId: 0,
          name: 'Strict-Transport-Security Header',
          description: 'The Strict-Transport-Security header is properly set, which helps prevent protocol downgrade attacks.',
          url,
          severity: 'safe',
          category: 'Header Configuration',
          details: { header: 'strict-transport-security', value: headers['strict-transport-security'] },
          status: 'safe',
          passed: true
        });
      } else {
        results.push({
          scanId: 0,
          name: 'Missing Strict-Transport-Security Header',
          description: 'The Strict-Transport-Security header is not set, which can lead to protocol downgrade attacks.',
          url,
          severity: 'medium',
          category: 'Header Configuration',
          details: { header: 'strict-transport-security', missing: true },
          status: 'pending',
          passed: false
        });
      }
    }
    
    // Check X-Content-Type-Options
    if (headers['x-content-type-options']) {
      results.push({
        scanId: 0,
        name: 'X-Content-Type-Options Header',
        description: 'The X-Content-Type-Options header is properly set, which helps prevent MIME-sniffing attacks.',
        url,
        severity: 'safe',
        category: 'Header Configuration',
        details: { header: 'x-content-type-options', value: headers['x-content-type-options'] },
        status: 'safe',
        passed: true
      });
    } else {
      results.push({
        scanId: 0,
        name: 'Missing X-Content-Type-Options Header',
        description: 'The X-Content-Type-Options header is not set, which can lead to MIME-sniffing attacks.',
        url,
        severity: 'low',
        category: 'Header Configuration',
        details: { header: 'x-content-type-options', missing: true },
        status: 'pending',
        passed: false
      });
    }
    
    // Check X-Frame-Options
    if (headers['x-frame-options']) {
      results.push({
        scanId: 0,
        name: 'X-Frame-Options Header',
        description: 'The X-Frame-Options header is properly set, which helps prevent clickjacking attacks.',
        url,
        severity: 'safe',
        category: 'Header Configuration',
        details: { header: 'x-frame-options', value: headers['x-frame-options'] },
        status: 'safe',
        passed: true
      });
    } else {
      results.push({
        scanId: 0,
        name: 'Missing X-Frame-Options Header',
        description: 'The X-Frame-Options header is not set, which can lead to clickjacking attacks.',
        url,
        severity: 'medium',
        category: 'Header Configuration',
        details: { header: 'x-frame-options', missing: true },
        status: 'pending',
        passed: false
      });
    }
    
    // Check Referrer-Policy
    if (headers['referrer-policy']) {
      results.push({
        scanId: 0,
        name: 'Referrer-Policy Header',
        description: 'The Referrer-Policy header is properly set, which helps protect user privacy.',
        url,
        severity: 'safe',
        category: 'Header Configuration',
        details: { header: 'referrer-policy', value: headers['referrer-policy'] },
        status: 'safe',
        passed: true
      });
    } else {
      results.push({
        scanId: 0,
        name: 'Missing Referrer-Policy Header',
        description: 'The Referrer-Policy header is not set, which can lead to privacy issues.',
        url,
        severity: 'low',
        category: 'Header Configuration',
        details: { header: 'referrer-policy', missing: true },
        status: 'pending',
        passed: false
      });
    }
  }
  
  private checkCookies(url: string, response: AxiosResponse, results: SecurityCheckResult[]) {
    const setCookieHeader = response.headers['set-cookie'];
    
    // Cookieがない場合は安全と判断
    if (!setCookieHeader) {
      results.push({
        scanId: 0,
        name: 'No Cookies Set',
        description: 'No cookies are set by this page, which reduces client-side security risks.',
        url,
        severity: 'safe',
        category: 'Cookie Security',
        details: { noCookies: true },
        status: 'safe',
        passed: true
      });
      return;
    }
    
    const cookies = Array.isArray(setCookieHeader) ? setCookieHeader : [setCookieHeader];
    let allCookiesSecure = true;
    let allCookiesHttpOnly = true;
    let allCookiesSameSite = true;
    
    for (const cookie of cookies) {
      const isSecure = cookie.toLowerCase().includes('secure');
      const isHttpOnly = cookie.toLowerCase().includes('httponly');
      const hasSameSite = cookie.toLowerCase().includes('samesite');
      
      if (url.startsWith('https') && !isSecure) {
        results.push({
          scanId: 0,
          name: 'Insecure Cookie (Missing Secure Flag)',
          description: 'A cookie is set without the Secure flag, which means it can be transmitted over unencrypted connections.',
          url,
          severity: 'medium',
          category: 'Cookie Security',
          details: { cookie, secure: false },
          status: 'pending',
          passed: false
        });
        allCookiesSecure = false;
      }
      
      if (!isHttpOnly) {
        results.push({
          scanId: 0,
          name: 'Insecure Cookie (Missing HttpOnly Flag)',
          description: 'A cookie is set without the HttpOnly flag, which means it can be accessed by JavaScript.',
          url,
          severity: 'medium',
          category: 'Cookie Security',
          details: { cookie, httpOnly: false },
          status: 'pending',
          passed: false
        });
        allCookiesHttpOnly = false;
      }
      
      if (!hasSameSite) {
        results.push({
          scanId: 0,
          name: 'Insecure Cookie (Missing SameSite Attribute)',
          description: 'A cookie is set without the SameSite attribute, which can lead to CSRF attacks.',
          url,
          severity: 'low',
          category: 'Cookie Security',
          details: { cookie, sameSite: false },
          status: 'pending',
          passed: false
        });
        allCookiesSameSite = false;
      }
    }
    
    // すべてのCookieがセキュアな場合、安全なチェック項目を追加
    if (allCookiesSecure && url.startsWith('https')) {
      results.push({
        scanId: 0,
        name: 'Secure Cookies',
        description: 'All cookies use the Secure flag, which ensures they are only transmitted over HTTPS connections.',
        url,
        severity: 'safe',
        category: 'Cookie Security',
        details: { secureFlag: true, cookiesCount: cookies.length },
        status: 'safe',
        passed: true
      });
    }
    
    if (allCookiesHttpOnly) {
      results.push({
        scanId: 0,
        name: 'HttpOnly Cookies',
        description: 'All cookies use the HttpOnly flag, which prevents access via client-side scripts.',
        url,
        severity: 'safe',
        category: 'Cookie Security',
        details: { httpOnlyFlag: true, cookiesCount: cookies.length },
        status: 'safe',
        passed: true
      });
    }
    
    if (allCookiesSameSite) {
      results.push({
        scanId: 0,
        name: 'SameSite Cookies',
        description: 'All cookies use the SameSite attribute, which provides protection against CSRF attacks.',
        url,
        severity: 'safe',
        category: 'Cookie Security',
        details: { sameSiteFlag: true, cookiesCount: cookies.length },
        status: 'safe',
        passed: true
      });
    }
  }
  
  private checkXssVulnerabilities(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    if (response.headers['content-type']?.includes('text/html')) {
      try {
        const $ = cheerio.load(response.data);
        
        // Check for reflected parameters in HTML content
        const urlObj = new URL(url);
        const params = urlObj.searchParams;
        
        // URLSearchParamsをArray化して扱う
        Array.from(params.entries()).forEach(([param, value]) => {
          if (value && response.data.includes(value)) {
            const escapedValue = value.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
            const regex = new RegExp(`${escapedValue}`, 'i');
            const matches = $(`:contains(${escapedValue})`).filter(function() {
              return regex.test($(this).text());
            });
            
            if (matches.length > 0) {
              vulnerabilities.push({
                scanId: 0,
                name: 'Potential Reflected XSS',
                description: `The URL parameter "${param}" is reflected in the page content without proper encoding.`,
                url,
                severity: 'high',
                category: 'Cross-Site Scripting',
                details: { parameter: param, value, reflectedCount: matches.length },
                status: 'pending',
              });
            }
          }
        });
        
        // Check for potentially dangerous inputs that don't properly sanitize input
        const unsafeInputs = $('input').filter(function() {
          const type = $(this).attr('type')?.toLowerCase();
          return !type || type === 'text' || type === 'search' || type === 'url' || type === 'textarea';
        }).not('[data-sanitized], [data-safe], [data-xss-safe]');
        
        if (unsafeInputs.length > 0) {
          vulnerabilities.push({
            scanId: 0,
            name: 'Potential DOM-based XSS',
            description: 'Found input fields without explicit XSS protection attributes.',
            url,
            severity: 'medium',
            category: 'Cross-Site Scripting',
            details: { inputsCount: unsafeInputs.length },
            status: 'pending',
          });
        }
      } catch (error) {
        console.error(`Error checking for XSS vulnerabilities at ${url}:`, error);
      }
    }
  }
  
  private checkJavaScriptLibraries(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    if (response.headers['content-type']?.includes('text/html')) {
      try {
        const $ = cheerio.load(response.data);
        const scripts = $('script[src]');
        
        // List of known vulnerable library patterns and their safe versions
        const vulnerableLibraries = [
          { name: 'jQuery', pattern: /jquery[.-]?([0-9]+\.[0-9]+\.[0-9]+)\.min\.js/i, vulnerableVersions: ['<1.9.0', '<2.1.4', '<3.0.0'] },
          { name: 'Bootstrap', pattern: /bootstrap[.-]?([0-9]+\.[0-9]+\.[0-9]+)\.min\.js/i, vulnerableVersions: ['<3.4.0', '<4.3.1'] },
          { name: 'AngularJS', pattern: /angular[.-]?([0-9]+\.[0-9]+\.[0-9]+)\.min\.js/i, vulnerableVersions: ['<1.6.0', '<1.7.9'] },
          { name: 'Lodash', pattern: /lodash[.-]?([0-9]+\.[0-9]+\.[0-9]+)\.min\.js/i, vulnerableVersions: ['<4.17.11'] },
        ];
        
        scripts.each((_, script) => {
          const src = $(script).attr('src') || '';
          
          for (const lib of vulnerableLibraries) {
            const match = src.match(lib.pattern);
            if (match && match[1]) {
              const version = match[1];
              
              // Very simplified version check, in a real app would use semantic versioning
              for (const vRange of lib.vulnerableVersions) {
                if (vRange.startsWith('<') && version < vRange.substring(1)) {
                  vulnerabilities.push({
                    scanId: 0,
                    name: `Vulnerable JavaScript Library: ${lib.name}`,
                    description: `Using potentially vulnerable version ${version} of ${lib.name}. ${vRange} versions are known to have security issues.`,
                    url,
                    severity: 'medium',
                    category: 'Outdated Libraries',
                    details: { library: lib.name, version, src },
                    status: 'pending',
                  });
                  break;
                }
              }
            }
          }
        });
      } catch (error) {
        console.error(`Error checking for vulnerable JavaScript libraries at ${url}:`, error);
      }
    }
  }
  
  private checkCsrfVulnerabilities(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    if (response.headers['content-type']?.includes('text/html')) {
      try {
        const $ = cheerio.load(response.data);
        const forms = $('form');
        
        forms.each((_, form) => {
          const method = $(form).attr('method')?.toLowerCase() || 'get';
          
          // Only check POST forms
          if (method === 'post') {
            const csrfToken = $(form).find('input[name*=csrf], input[name*=token], input[name*=xsrf], meta[name*=csrf]');
            
            if (csrfToken.length === 0) {
              vulnerabilities.push({
                scanId: 0,
                name: 'Potential CSRF Vulnerability',
                description: 'Found a form with POST method but no CSRF token.',
                url,
                severity: 'medium',
                category: 'Cross-Site Request Forgery',
                details: { action: $(form).attr('action') || 'Not specified' },
                status: 'pending',
              });
            }
          }
        });
      } catch (error) {
        console.error(`Error checking for CSRF vulnerabilities at ${url}:`, error);
      }
    }
  }
  
  private checkSqlInjectionVulnerabilities(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    // Check URL for SQL injection parameters
    const urlObj = new URL(url);
    const params = urlObj.searchParams;
    
    const sqlInjectionPatterns = [
      'id=',
      'user_id=',
      'product_id=',
      'category_id=',
      'article_id=',
      'page_id=',
      'query=',
      'search=',
      'file=',
      'view=',
    ];
    
    // URLSearchParamsをArray化して扱う
    Array.from(params.entries()).forEach(([param, value]) => {
      for (const pattern of sqlInjectionPatterns) {
        if (param.toLowerCase().includes(pattern.replace('=', ''))) {
          vulnerabilities.push({
            scanId: 0,
            name: 'Potential SQL Injection Point',
            description: `The URL parameter "${param}" might be vulnerable to SQL injection.`,
            url,
            severity: 'high',
            category: 'SQL Injection',
            details: { parameter: param, value },
            status: 'pending',
          });
          break;
        }
      }
    });
    
    // Check forms for SQL injection fields
    if (response.headers['content-type']?.includes('text/html')) {
      try {
        const $ = cheerio.load(response.data);
        const forms = $('form');
        
        forms.each((_, form) => {
          const inputs = $(form).find('input[type="text"], input:not([type]), textarea');
          
          inputs.each((_, input) => {
            const name = $(input).attr('name')?.toLowerCase() || '';
            for (const pattern of sqlInjectionPatterns) {
              if (name.includes(pattern.replace('=', ''))) {
                vulnerabilities.push({
                  scanId: 0,
                  name: 'Potential SQL Injection Point in Form',
                  description: `The form field "${name}" might be vulnerable to SQL injection.`,
                  url,
                  severity: 'high',
                  category: 'SQL Injection',
                  details: { form: $(form).attr('action') || 'Not specified', field: name },
                  status: 'pending',
                });
                break;
              }
            }
          });
        });
      } catch (error) {
        console.error(`Error checking for SQL injection vulnerabilities at ${url}:`, error);
      }
    }
  }
  
  private checkSensitiveInformationLeakage(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    const sensitivePatterns = [
      /password\s*[:=]\s*['"][^'"]+['"]?/i,
      /apikey\s*[:=]\s*['"][^'"]+['"]?/i,
      /api_key\s*[:=]\s*['"][^'"]+['"]?/i,
      /secret\s*[:=]\s*['"][^'"]+['"]?/i,
      /token\s*[:=]\s*['"][^'"]+['"]?/i,
      /access_token\s*[:=]\s*['"][^'"]+['"]?/i,
      /connection_string\s*[:=]\s*['"][^'"]+['"]?/i,
      /private_key\s*[:=]/i,
      /BEGIN\s+(?:RSA\s+)?PRIVATE\s+KEY/i,
      /aws_access_key_id\s*[:=]/i,
      /credentials\s*[:=]/i,
    ];
    
    const contentType = response.headers['content-type'] || '';
    
    // Check HTML, JavaScript, CSS, JSON, and plain text responses
    if (contentType.includes('text/html') || 
        contentType.includes('application/javascript') || 
        contentType.includes('text/javascript') || 
        contentType.includes('text/css') || 
        contentType.includes('application/json') || 
        contentType.includes('text/plain')) {
      
      const content = typeof response.data === 'string' ? response.data : JSON.stringify(response.data);
      
      for (const pattern of sensitivePatterns) {
        const matches = content.match(pattern);
        if (matches) {
          vulnerabilities.push({
            scanId: 0,
            name: 'Sensitive Information Exposure',
            description: 'Detected potentially sensitive information in the response.',
            url,
            severity: 'high',
            category: 'Information Leakage',
            details: { pattern: pattern.toString(), matchesCount: matches.length },
            status: 'pending',
          });
          break; // No need to report the same vulnerability multiple times
        }
      }
    }
    
    // Check for error messages that might reveal sensitive information
    const errorPatterns = [
      /\bSQL\s+error\b/i,
      /\bSQL\s+syntax\b/i,
      /\bORA-[0-9]+\b/i, // Oracle errors
      /\bMySQL\s+error\b/i,
      /\bSQLState\b/i,
      /\bDB2\s+SQL\s+error\b/i,
      /\bexception\s+at\s+org\.hibernate\b/i,
      /\bSQLServer\b/i,
      /\bSystemError\b/i,
      /\bFatal\s+error\b/i,
      /\bUncaught\s+exception\b/i,
      /\bstack\s+trace\b/i,
    ];
    
    if (typeof response.data === 'string') {
      for (const pattern of errorPatterns) {
        const matches = response.data.match(pattern);
        if (matches) {
          vulnerabilities.push({
            scanId: 0,
            name: 'Error Information Disclosure',
            description: 'Detected error messages that might reveal sensitive information.',
            url,
            severity: 'medium',
            category: 'Information Leakage',
            details: { pattern: pattern.toString(), matchesCount: matches.length },
            status: 'pending',
          });
          break; // No need to report the same vulnerability multiple times
        }
      }
    }
  }
  
  private checkInsecurePasswordFields(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    // Check if the page contains password fields over HTTP
    if (!url.startsWith('https') && 
        response.headers['content-type']?.includes('text/html')) {
      try {
        const $ = cheerio.load(response.data);
        const passwordFields = $('input[type="password"]');
        
        if (passwordFields.length > 0) {
          vulnerabilities.push({
            scanId: 0,
            name: 'Password Field Over Insecure Connection',
            description: 'Found password input fields on a page served over HTTP instead of HTTPS.',
            url,
            severity: 'high',
            category: 'Insecure Connection',
            details: { fieldsCount: passwordFields.length },
            status: 'pending',
          });
        }
      } catch (error) {
        console.error(`Error checking for insecure password fields at ${url}:`, error);
      }
    }
  }
  
  // サーバー情報の漏洩をチェック
  private checkServerInformationLeakage(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    const headers = response.headers;
    
    // Serverヘッダーの詳細な情報チェック
    if (headers['server'] && headers['server'] !== '') {
      const serverHeader = headers['server'];
      
      // 詳細なサーバーバージョン情報（例：Apache/2.4.29, nginx/1.14.0など）
      const versionRegex = /[a-zA-Z]+\/[0-9]+\.[0-9]+(\.[0-9]+)?/;
      if (versionRegex.test(serverHeader)) {
        vulnerabilities.push({
          scanId: 0,
          name: 'Server Information Disclosure',
          description: 'The server is disclosing detailed version information, which could help attackers identify specific vulnerabilities.',
          url,
          severity: 'medium',
          category: 'Information Disclosure',
          details: { header: 'Server', value: serverHeader },
          status: 'pending',
        });
      }
    }
    
    // X-Powered-Byヘッダーのチェック
    if (headers['x-powered-by'] && headers['x-powered-by'] !== '') {
      vulnerabilities.push({
        scanId: 0,
        name: 'Technology Information Disclosure',
        description: 'The X-Powered-By header is revealing the technology stack, which could help attackers target specific vulnerabilities.',
        url,
        severity: 'low',
        category: 'Information Disclosure',
        details: { header: 'X-Powered-By', value: headers['x-powered-by'] },
        status: 'pending',
      });
    }
  }
  
  // ファイルアップロード機能の安全性チェック
  private checkFileUploadVulnerabilities(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    if (response.headers['content-type']?.includes('text/html')) {
      try {
        const $ = cheerio.load(response.data);
        const fileInputs = $('input[type="file"]');
        
        if (fileInputs.length > 0) {
          // 拡張子制限属性のチェック
          fileInputs.each((_, input) => {
            const accept = $(input).attr('accept');
            if (!accept) {
              vulnerabilities.push({
                scanId: 0,
                name: 'Unrestricted File Upload',
                description: 'Found a file upload field without file type restrictions, which could be abused for uploading malicious files.',
                url,
                severity: 'high',
                category: 'File Upload',
                details: { 
                  element: input.name, 
                  formAction: $(input).closest('form').attr('action') || 'Not specified' 
                },
                status: 'pending',
              });
            } else if (accept.includes('*') || accept.includes('.php') || accept.includes('.asp') || accept.includes('.aspx') || accept.includes('.exe') || accept.includes('.jsp')) {
              vulnerabilities.push({
                scanId: 0,
                name: 'Potentially Dangerous File Upload',
                description: 'Found a file upload field that accepts potentially dangerous file types.',
                url,
                severity: 'high',
                category: 'File Upload',
                details: { 
                  element: input.name, 
                  acceptTypes: accept,
                  formAction: $(input).closest('form').attr('action') || 'Not specified' 
                },
                status: 'pending',
              });
            }
          });
          
          // マルチパートフォームのエンコードタイプチェック
          fileInputs.each((_, input) => {
            const form = $(input).closest('form');
            const enctype = form.attr('enctype');
            
            if (!enctype || enctype !== 'multipart/form-data') {
              vulnerabilities.push({
                scanId: 0,
                name: 'Incorrect File Upload Form Configuration',
                description: 'File upload form is missing the required enctype="multipart/form-data" attribute.',
                url,
                severity: 'medium',
                category: 'File Upload',
                details: { 
                  formAction: form.attr('action') || 'Not specified',
                  enctype: enctype || 'Not specified'
                },
                status: 'pending',
              });
            }
          });
        }
      } catch (error) {
        console.error(`Error checking for file upload vulnerabilities at ${url}:`, error);
      }
    }
  }
  
  // CORSポリシーの設定チェック
  private checkCorsPolicy(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    const headers = response.headers;
    
    // Access-Control-Allow-Originが'*'または広範囲に設定されているかチェック
    if (headers['access-control-allow-origin'] === '*') {
      vulnerabilities.push({
        scanId: 0,
        name: 'Overly Permissive CORS Policy',
        description: 'The Access-Control-Allow-Origin header is set to "*", which allows any origin to access the resource.',
        url,
        severity: 'medium',
        category: 'CORS Misconfiguration',
        details: { header: 'Access-Control-Allow-Origin', value: '*' },
        status: 'pending',
      });
    } else if (headers['access-control-allow-origin'] && 
               !headers['access-control-allow-origin'].startsWith('https://') &&
               headers['access-control-allow-origin'] !== 'null') {
      vulnerabilities.push({
        scanId: 0,
        name: 'Potentially Insecure CORS Policy',
        description: 'The Access-Control-Allow-Origin header is set to a non-HTTPS origin, which could lead to data interception.',
        url,
        severity: 'low',
        category: 'CORS Misconfiguration',
        details: { header: 'Access-Control-Allow-Origin', value: headers['access-control-allow-origin'] },
        status: 'pending',
      });
    }
    
    // Access-Control-Allow-Credentialsが特定のoriginに対して設定されているかチェック
    if (headers['access-control-allow-credentials'] === 'true' && headers['access-control-allow-origin'] === '*') {
      vulnerabilities.push({
        scanId: 0,
        name: 'Dangerous CORS Configuration',
        description: 'Access-Control-Allow-Credentials is set to true with a wildcard Access-Control-Allow-Origin, which is a dangerous combination.',
        url,
        severity: 'high',
        category: 'CORS Misconfiguration',
        details: { 
          'Access-Control-Allow-Origin': headers['access-control-allow-origin'],
          'Access-Control-Allow-Credentials': headers['access-control-allow-credentials']
        },
        status: 'pending',
      });
    }
  }
  
  // robots.txtファイルの解析
  private checkRobotsTxt(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    if (url.endsWith('/robots.txt')) {
      try {
        const content = response.data.toString();
        const sensitivePathsRegex = /(Disallow:\s*\/admin|Disallow:\s*\/user|Disallow:\s*\/login|Disallow:\s*\/account|Disallow:\s*\/dashboard|Disallow:\s*\/secure|Disallow:\s*\/private|Disallow:\s*\/backup|Disallow:\s*\/config|Disallow:\s*\/setting)/gi;
        const matches = content.match(sensitivePathsRegex);
        
        if (matches && matches.length > 0) {
          vulnerabilities.push({
            scanId: 0,
            name: 'Sensitive Information in robots.txt',
            description: 'The robots.txt file contains references to sensitive paths that should not be publicly disclosed.',
            url,
            severity: 'medium',
            category: 'Information Disclosure',
            details: { 
              sensitiveEntries: matches,
              content: content.substring(0, 500) + (content.length > 500 ? '...' : '')
            },
            status: 'pending',
          });
        }
      } catch (error) {
        console.error(`Error analyzing robots.txt at ${url}:`, error);
      }
    } else if (url.endsWith('/') || url.endsWith('index.html') || url.endsWith('index.php')) {
      // トップページの場合、robots.txtへのリンクを探す
      try {
        const robotsUrl = new URL('/robots.txt', url).toString();
        // ここではロボットファイルへの直接アクセスは行わず、脆弱性として示唆するのみ
        vulnerabilities.push({
          scanId: 0,
          name: 'Robots.txt Analysis Recommended',
          description: 'Consider examining robots.txt for sensitive information disclosure.',
          url: robotsUrl,
          severity: 'info',
          category: 'Information Gathering',
          details: { suggestedUrl: robotsUrl },
          status: 'pending',
        });
      } catch (error) {
        console.error(`Error suggesting robots.txt check for ${url}:`, error);
      }
    }
  }
  
  // 古いHTTPプロトコルのチェック
  private checkOldHttpProtocol(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    const httpVersion = response.request?.res?.httpVersion;
    
    if (httpVersion && httpVersion < '2') {
      const severity = httpVersion === '1.0' ? 'medium' : 'low';
      
      vulnerabilities.push({
        scanId: 0,
        name: 'Outdated HTTP Protocol',
        description: `The server is using HTTP/${httpVersion}, which may lack security features and optimizations available in newer versions.`,
        url,
        severity,
        category: 'Outdated Technology',
        details: { httpVersion },
        status: 'pending',
      });
    }
  }
  
  // HTMLコメント内の機密情報をチェック
  private checkCommentsForSensitiveInfo(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    if (response.headers['content-type']?.includes('text/html')) {
      try {
        const content = typeof response.data === 'string' ? response.data : response.data.toString();
        
        // HTMLコメント内の検出パターン
        const sensitivePatterns = [
          /<!--.*password.*-->/i,
          /<!--.*username.*-->/i,
          /<!--.*api\s*key.*-->/i,
          /<!--.*todo.*-->/i,
          /<!--.*fix.*-->/i,
          /<!--.*hack.*-->/i,
          /<!--.*workaround.*-->/i,
          /<!--.*secret.*-->/i,
          /<!--.*credentials.*-->/i,
          /<!--.*token.*-->/i
        ];
        
        const matches: string[] = [];
        
        for (const pattern of sensitivePatterns) {
          const commentMatches = content.match(pattern);
          if (commentMatches) {
            matches.push(...commentMatches);
          }
        }
        
        if (matches.length > 0) {
          vulnerabilities.push({
            scanId: 0,
            name: 'Sensitive Information in HTML Comments',
            description: 'Found potentially sensitive information in HTML comments, which might reveal implementation details or credentials.',
            url,
            severity: 'medium',
            category: 'Information Disclosure',
            details: { 
              comments: matches.map(comment => 
                comment.length > 50 
                  ? comment.substring(0, 50) + '...' 
                  : comment
              ) 
            },
            status: 'pending',
          });
        }
      } catch (error) {
        console.error(`Error checking HTML comments at ${url}:`, error);
      }
    }
  }
  
  // 古いTLS/SSLバージョンのチェック
  private checkOldTlsVersions(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    // 注意: ヘッダー情報からのみでは完全な判断はできないため、
    // サーバーが送信する情報に基づく限定的なチェックのみを行います
    
    // サーバーが安全でないTLSバージョンをサポートしている可能性があるかどうかを推測
    const serverHeader = response.headers['server'] || '';
    
    // 古いWebサーバーバージョンで既知のTLS問題があるパターン
    const knownVulnerableServers = [
      { pattern: /Apache\/2\.[0-3]\./, description: 'Apache 2.0-2.3' },
      { pattern: /nginx\/1\.[0-9]\./, description: 'Older Nginx 1.x' },
      { pattern: /Microsoft-IIS\/[1-6]\./, description: 'IIS 6 or older' },
      { pattern: /IBM_HTTP_Server\/1\./, description: 'IBM HTTP Server 1.x' },
    ];
    
    for (const server of knownVulnerableServers) {
      if (server.pattern.test(serverHeader)) {
        vulnerabilities.push({
          scanId: 0,
          name: 'Potentially Vulnerable TLS Configuration',
          description: `The server (${server.description}) may support outdated TLS/SSL versions, which are vulnerable to attacks.`,
          url,
          severity: 'high',
          category: 'Outdated Technology',
          details: { 
            serverHeader, 
            recommendation: 'Configure the server to use only TLS 1.2 or higher and disable older protocols.'
          },
          status: 'pending',
        });
        break;
      }
    }
  }
  
  // 未認証エンドポイントのチェック
  private checkUnauthenticatedEndpoints(url: string, response: AxiosResponse, vulnerabilities: InsertVulnerability[]) {
    // URLパスをチェックして、一般的に認証が必要なエンドポイントパターンを検出
    const uriPath = new URL(url).pathname.toLowerCase();
    
    const sensitiveEndpoints = [
      { pattern: /\/admin(\/|$)/, name: 'Admin Interface' },
      { pattern: /\/dashboard(\/|$)/, name: 'Dashboard' },
      { pattern: /\/account(\/|$)/, name: 'Account Management' },
      { pattern: /\/user(\/|$)/, name: 'User Management' },
      { pattern: /\/settings(\/|$)/, name: 'Settings' },
      { pattern: /\/profile(\/|$)/, name: 'User Profile' },
      { pattern: /\/config(\/|$)/, name: 'Configuration' },
      { pattern: /\/api\/.*\/(delete|remove|update|create|add|edit)(\/|$)/, name: 'API Modification Endpoint' },
      { pattern: /\/manage(\/|$)/, name: 'Management Interface' },
      { pattern: /\/control(\/|$)/, name: 'Control Panel' },
    ];
    
    for (const endpoint of sensitiveEndpoints) {
      if (endpoint.pattern.test(uriPath) && response.status !== 401 && response.status !== 403) {
        vulnerabilities.push({
          scanId: 0,
          name: 'Potentially Unprotected Sensitive Endpoint',
          description: `The ${endpoint.name} endpoint (${uriPath}) might be accessible without proper authentication.`,
          url,
          severity: 'high',
          category: 'Access Control',
          details: { 
            endpoint: uriPath, 
            expectedProtection: endpoint.name,
            responseStatus: response.status,
            recommendation: 'Verify that this endpoint requires proper authentication and authorization.'
          },
          status: 'pending',
        });
        break;
      }
    }
  }
}

export const vulnerabilityDetector = new VulnerabilityDetector();
