import { Request, Response } from 'express';
import { storage } from '../storage';
import { z } from 'zod';

// Validate vulnerability update request
const updateVulnerabilitySchema = z.object({
  status: z.enum(['pending', 'in_progress', 'fixed', 'false_positive', 'open', 'safe']).optional(),
});

export const vulnerabilityController = {
  // Get all vulnerabilities for the current user
  getUserVulnerabilities: async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized' });
      }
      
      const user = req.user;
      
      // First get all scans for the user
      const scans = await storage.getScansByUserId(user.id);
      
      // Then get vulnerabilities for each scan
      const vulnerabilitiesPromises = scans.map(scan => 
        storage.getVulnerabilitiesByScanId(scan.id)
      );
      
      const vulnerabilitiesArrays = await Promise.all(vulnerabilitiesPromises);
      
      // Flatten the array of arrays
      const vulnerabilities = vulnerabilitiesArrays.flat();
      
      return res.status(200).json(vulnerabilities);
    } catch (error) {
      console.error('Error getting user vulnerabilities:', error);
      return res.status(500).json({ message: 'Internal server error' });
    }
  },
  
  // Get a specific vulnerability
  getVulnerability: async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized' });
      }
      
      const user = req.user;
      const vulnerabilityId = parseInt(req.params.id, 10);
      
      if (isNaN(vulnerabilityId)) {
        return res.status(400).json({ message: 'Invalid vulnerability ID' });
      }
      
      const vulnerability = await storage.getVulnerability(vulnerabilityId);
      
      if (!vulnerability) {
        return res.status(404).json({ message: 'Vulnerability not found' });
      }
      
      // Check if the vulnerability belongs to the user's scan
      const scan = await storage.getScan(vulnerability.scanId);
      
      if (!scan || scan.userId !== user.id) {
        return res.status(403).json({ message: 'Unauthorized access to vulnerability' });
      }
      
      return res.status(200).json(vulnerability);
    } catch (error) {
      console.error('Error getting vulnerability:', error);
      return res.status(500).json({ message: 'Internal server error' });
    }
  },
  
  // Update a vulnerability
  updateVulnerability: async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized' });
      }
      
      const user = req.user;
      const vulnerabilityId = parseInt(req.params.id, 10);
      
      if (isNaN(vulnerabilityId)) {
        return res.status(400).json({ message: 'Invalid vulnerability ID' });
      }
      
      // Validate request data
      const validation = updateVulnerabilitySchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({ message: 'Invalid update data', errors: validation.error.errors });
      }
      
      const updateData = validation.data;
      
      const vulnerability = await storage.getVulnerability(vulnerabilityId);
      
      if (!vulnerability) {
        return res.status(404).json({ message: 'Vulnerability not found' });
      }
      
      // Check if the vulnerability belongs to the user's scan
      const scan = await storage.getScan(vulnerability.scanId);
      
      if (!scan || scan.userId !== user.id) {
        return res.status(403).json({ message: 'Unauthorized access to vulnerability' });
      }
      
      // Update vulnerability
      const updatedVulnerability = await storage.updateVulnerability(vulnerabilityId, updateData);
      
      // Log security event
      if (updateData.status) {
        await storage.createSecurityEvent({
          userId: user.id,
          type: 'vulnerability_updated',
          description: `Vulnerability status updated to ${updateData.status}`,
          metadata: {
            vulnerabilityId,
            name: vulnerability.name,
            oldStatus: vulnerability.status,
            newStatus: updateData.status,
          },
        });
      }
      
      return res.status(200).json(updatedVulnerability);
    } catch (error) {
      console.error('Error updating vulnerability:', error);
      return res.status(500).json({ message: 'Internal server error' });
    }
  },
  
  // Get vulnerability count by severity
  getVulnerabilitySummary: async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized' });
      }
      
      const user = req.user;
      
      // First get all scans for the user
      const scans = await storage.getScansByUserId(user.id);
      
      // Then get vulnerabilities for each scan
      const vulnerabilitiesPromises = scans.map(scan => 
        storage.getVulnerabilitiesByScanId(scan.id)
      );
      
      const vulnerabilitiesArrays = await Promise.all(vulnerabilitiesPromises);
      
      // Flatten the array of arrays
      const vulnerabilities = vulnerabilitiesArrays.flat();
      
      // Count vulnerabilities by severity and status
      const summary = {
        total: vulnerabilities.length,
        bySeverity: {
          high: vulnerabilities.filter(v => v.severity === 'high').length,
          medium: vulnerabilities.filter(v => v.severity === 'medium').length,
          low: vulnerabilities.filter(v => v.severity === 'low').length,
          safe: vulnerabilities.filter(v => v.severity === 'safe').length,
        },
        byStatus: {
          pending: vulnerabilities.filter(v => v.status === 'pending').length,
          in_progress: vulnerabilities.filter(v => v.status === 'in_progress').length,
          fixed: vulnerabilities.filter(v => v.status === 'fixed').length,
          false_positive: vulnerabilities.filter(v => v.status === 'false_positive').length,
          open: vulnerabilities.filter(v => v.status === 'open').length,
          safe: vulnerabilities.filter(v => v.status === 'safe').length,
        }
      };
      
      // Calculate security score
      // Simple formula: 100 - (high * 10 + medium * 5 + low * 2)
      // This can be adjusted as needed
      const highWeight = 10;
      const mediumWeight = 5;
      const lowWeight = 2;
      
      let securityScore = 100 - (
        summary.bySeverity.high * highWeight + 
        summary.bySeverity.medium * mediumWeight + 
        summary.bySeverity.low * lowWeight
      );
      
      // Ensure score is between 0 and 100
      securityScore = Math.max(0, Math.min(100, securityScore));
      
      return res.status(200).json({
        ...summary,
        securityScore,
      });
    } catch (error) {
      console.error('Error getting vulnerability summary:', error);
      return res.status(500).json({ message: 'Internal server error' });
    }
  },
};
